/*
* This file is part of rasdaman community.
*
* Rasdaman community is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* Rasdaman community is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with rasdaman community.  If not, see <http://www.gnu.org/licenses/>.
*
* Copyright 2003, 2004, 2005, 2006, 2007, 2008, 2009 Peter Baumann /
rasdaman GmbH.
*
* For more information please see <http://www.rasdaman.org>
* or contact Peter Baumann via <baumann@rasdaman.com>.
*/
/****************************************************************************
 *
 *
 * PURPOSE:
 * Code with embedded SQL for PostgreSQL DBMS
 *
 *
 * COMMENTS:
 *  none
 *
 ****************************************************************************/

#include "config.h"
#include "reladminif/sqlerror.hh"
#include "reladminif/externs.h"
#include "dbstoragelayout.hh"
#include "storagemgr/sstoragelayout.hh"
#include "reladminif/objectbroker.hh"

DBStorageLayout::DBStorageLayout()
    :   DBObject(),
        indexType(StorageLayout::DefaultIndexType),
        indexSize(StorageLayout::DefaultIndexSize),
        tilingScheme(StorageLayout::DefaultTilingScheme),
        tileSize(StorageLayout::DefaultTileSize),
        tileConfiguration(new DBMinterval()),
        dataFormat(StorageLayout::DefaultDataFormat),
        pctMin(StorageLayout::DefaultMinimalTileSize),
        pctMax(StorageLayout::DefaultPCTMax),
        _supportsTileSize(false),
        _supportsPCTMin(false),
        _supportsPCTMax(false),
        _supportsIndexSize(false),
        _supportsIndexType(false),
        _supportsTiling(false),
        _supportsTileConfiguration(false),
        _supportsDataFormat(false)
{
    objecttype = OId::STORAGEOID;
}

DBStorageLayout::DBStorageLayout(const OId& id)
    :   DBObject(id),
        indexType(StorageLayout::DefaultIndexType),
        indexSize(StorageLayout::DefaultIndexSize),
        tilingScheme(StorageLayout::DefaultTilingScheme),
        tileSize(StorageLayout::DefaultTileSize),
        tileConfiguration(new DBMinterval()),
        dataFormat(StorageLayout::DefaultDataFormat),
        pctMin(StorageLayout::DefaultMinimalTileSize),
        pctMax(StorageLayout::DefaultPCTMax),
        _supportsTileSize(false),
        _supportsPCTMin(false),
        _supportsPCTMax(false),
        _supportsIndexSize(false),
        _supportsIndexType(false),
        _supportsTiling(false),
        _supportsTileConfiguration(false),
        _supportsDataFormat(false)
{
    objecttype = OId::STORAGEOID;
    readFromDb();
}

void
DBStorageLayout::printStatus(unsigned int level, std::ostream& stream) const
{
    char* indent = new char[level*2 +1];
    for (int j = 0; j < level*2 ; j++)
        indent[j] = ' ';
    indent[level*2] = '\0';

    stream << indent;
    stream << "DBStorageLayout:" << endl;
    if (supportsTileSize())
        stream << "\tTileSize\t\t\t:";
    else
        stream << "\tTileSize (Def.)\t\t\t:";
    stream << getTileSize() << endl;
    stream << indent;
    if (supportsPCTMin())
        stream << "\tPCTMin\t\t:";
    else
        stream << "\tPCTMin (Def.)\t\t\t:";
    stream << getPCTMin() << endl;
    stream << indent;
    if (supportsPCTMax())
        stream << "\tPCTMax\t\t:";
    else
        stream << "\tPCTMax (Def.)\t\t\t:";
    stream << getPCTMax() << endl;
    stream << indent;
    if (supportsIndexSize())
        stream << "\tIndexSize\t\t:";
    else
        stream << "\tIndexSize (Def.)\t\t:";
    stream << getIndexSize() << endl;
    stream << indent;
    if (supportsIndexType())
        stream << "\tIndexType\t\t\t:";
    else
        stream << "\tIndexType (Def.)\t\t:";
    stream << getIndexType() << endl;
    stream << indent;
    if (supportsTilingScheme())
        stream << "\tTilingScheme\t\t\t:";
    else
        stream << "\tTilingScheme (Def.)\t\t:";
    stream << getTilingScheme() << endl;
    stream << indent;
    if (supportsTileConfiguration())
        stream << "\tTileConfiguration\t\t:";
    else
        stream << "\tTileConfiguration (Def.)\t:";
    stream << getTileConfiguration() << endl;
    stream << indent;
    if (supportsDataFormat())
        stream << "\tDataFormat\t\t\t:";
    else
        stream << "\tDataFormat (Def.)\t\t:";
    stream << getDataFormat() << endl;
    stream << indent;

    delete[] indent;
}

bool
DBStorageLayout::supportsIndexType() const
{
    return _supportsIndexType;
}

bool
DBStorageLayout::supportsDataFormat() const
{
    return _supportsDataFormat;
}

bool
DBStorageLayout::supportsTilingScheme() const
{
    return _supportsTiling;
}

bool
DBStorageLayout::supportsTileSize() const
{
    return _supportsTileSize;
}

bool
DBStorageLayout::supportsIndexSize() const
{
    return _supportsIndexSize;
}

bool
DBStorageLayout::supportsPCTMin() const
{
    return _supportsPCTMin;
}

bool
DBStorageLayout::supportsPCTMax() const
{
    return _supportsPCTMax;
}

bool
DBStorageLayout::supportsTileConfiguration() const
{
    return _supportsTileConfiguration;
}

r_Index_Type
DBStorageLayout::getIndexType() const
{
    return indexType;
}

r_Data_Format
DBStorageLayout::getDataFormat() const
{
    return dataFormat;
}

r_Tiling_Scheme
DBStorageLayout::getTilingScheme() const
{
    return tilingScheme;
}

r_Bytes
DBStorageLayout::getTileSize() const
{
    return tileSize;
}

unsigned int
DBStorageLayout::getIndexSize() const
{
    return indexSize;
}

r_Bytes
DBStorageLayout::getPCTMin() const
{
    return pctMin;
}

r_Bytes
DBStorageLayout::getPCTMax() const
{
    return pctMax;
}

r_Minterval
DBStorageLayout::getTileConfiguration() const
{
    return *tileConfiguration;
}

void
DBStorageLayout::setIndexType(r_Index_Type it)
{
    _supportsIndexType = true;
    indexType = it;
    setModified();
}

void
DBStorageLayout::setDataFormat(r_Data_Format cs)
{
    _supportsDataFormat = true;
    dataFormat = cs;
    setModified();
}

void
DBStorageLayout::setTilingScheme(r_Tiling_Scheme ts)
{
    _supportsTiling = true;
    tilingScheme = ts;
    setModified();
}

void
DBStorageLayout::setTileSize(r_Bytes tsize)
{
    _supportsTileSize = true;
    tileSize = tsize;
    setModified();
}

void
DBStorageLayout::setTileConfiguration(const r_Minterval& tc)
{
    _supportsTileConfiguration = true;
    *tileConfiguration = tc;
    setModified();
}

void
DBStorageLayout::setIndexSize(unsigned int newindexSize)
{
    _supportsIndexSize = true;
    indexSize = newindexSize;
    setModified();
}

void
DBStorageLayout::setPCTMin(r_Bytes newpctMin)
{
    _supportsPCTMin = true;
    pctMin = newpctMin;
    setModified();
}

void
DBStorageLayout::setPCTMax(r_Bytes newpctMax)
{
    _supportsPCTMax = true;
    pctMax = newpctMax;
    setModified();
}

DBStorageLayout::~DBStorageLayout()
{
    validate();
}

/*
TABLE RAS_STORAGE (
    StorageId   INTEGER NOT NULL UNIQUE,
    DomainId    INTEGER,
    TileSize    INTEGER,
    PCTMin      INTEGER,
    PCTMax      INTEGER,
    IndexSize   INTEGER,
    IndexType   SMALLINT,
    TilingScheme    SMALLINT,
    DataFormat  SMALLINT
    )
*/

void
DBStorageLayout::readFromDb()
{
    EXEC SQL BEGIN DECLARE SECTION;
        long    storageid1;
        long    domainid1;
        short   domainid1ind;
        long    tilesize1;
        short   tilesize1ind;
        long    pctmin1;
        short   pctmin1ind;
        long    pctmax1;
        short   pctmax1ind;
        long    indexsize1;
        short   indexsize1ind;
        short   indextype1;
        short   indextype1ind;
        short   tilingscheme1;
        short   tilingscheme1ind;
        short   dataformat1;
        short   dataformat1ind;
    EXEC SQL END DECLARE SECTION;

    storageid1 = myOId.getCounter();
    EXEC SQL SELECT
        DomainId,
        TileSize,
        PCTMin,
        PCTMax,
        IndexType,
        TilingScheme,
        DataFormat,
        IndexSize
       INTO
        :domainid1 INDICATOR :domainid1ind,
        :tilesize1 INDICATOR :tilesize1ind,
        :pctmin1 INDICATOR :pctmin1ind,
        :pctmax1 INDICATOR :pctmax1ind,
        :indextype1 INDICATOR :indextype1ind,
        :tilingscheme1 INDICATOR :tilingscheme1ind,
        :dataformat1 INDICATOR :dataformat1ind,
        :indexsize1 INDICATOR :indexsize1ind
       FROM
        RAS_STORAGE
       WHERE
        StorageId = :storageid1;
    if (SQLCODE != SQLOK)
    {
        check("DBStorageLayout::readFromDb() SELECT FROM RAS_STORAGE");
        generateException();
    }

    if (domainid1ind)
    {
        _supportsTileConfiguration = false;
        //((DBMinterval)*tileConfiguration) = StorageLayout::DefaultTileConfiguration;
        *tileConfiguration = StorageLayout::DefaultTileConfiguration;
    }
    else
    {
        _supportsTileConfiguration = true;
        tileConfiguration = OId(domainid1, OId::DBMINTERVALOID);
    }

    if (indexsize1ind)
    {
        _supportsIndexSize = false;
        indexSize = StorageLayout::DefaultIndexSize;
    }
    else
    {
        _supportsIndexSize = true;
        indexSize = indexsize1;
    }

    if (tilesize1ind)
    {
        _supportsTileSize = false;
        tileSize = StorageLayout::DefaultTileSize;
    }
    else
    {
        _supportsTileSize = true;
        tileSize = tilesize1;
    }

    if (pctmin1ind)
    {
        _supportsPCTMin = false;
        pctMin = StorageLayout::DefaultMinimalTileSize;
    }
    else
    {
        _supportsPCTMin = true;
        pctMin = pctmin1;
    }

    if (pctmax1ind)
    {
        _supportsPCTMax = false;
        pctMax = StorageLayout::DefaultPCTMax;
    }
    else
    {
        _supportsPCTMax = true;
        pctMax = pctmax1;
    }

    if (indextype1ind)
    {
        _supportsIndexType = false;
        indexType = StorageLayout::DefaultIndexType;
    }
    else
    {
        _supportsIndexType = true;
        indexType = (r_Index_Type)indextype1;
    }

    if (tilingscheme1ind)
    {
        _supportsTiling = false;
        tilingScheme = StorageLayout::DefaultTilingScheme;
    }
    else
    {
        _supportsTiling = true;
        tilingScheme = (r_Tiling_Scheme)tilingscheme1;
    }

    if (dataformat1ind)
    {
        _supportsDataFormat = false;
        dataFormat = StorageLayout::DefaultDataFormat;
    }
    else
    {
        _supportsDataFormat = true;
        dataFormat = (r_Data_Format)dataformat1;
    }

    DBObject::readFromDb();
}

void
DBStorageLayout::updateInDb()
{
    deleteFromDb();
    insertInDb();
    DBObject::updateInDb();
}

void
DBStorageLayout::insertInDb()
{
    EXEC SQL BEGIN DECLARE SECTION;
        long    storageid2;
        long    domainid2;
        short   domainid2ind;
        long    tilesize2;
        short   tilesize2ind;
        long    pctmin2;
        short   pctmin2ind;
        long    pctmax2;
        short   pctmax2ind;
        long    indexsize2;
        short   indexsize2ind;
        short   indextype2;
        short   indextype2ind;
        short   tilingscheme2;
        short   tilingscheme2ind;
        short   dataformat2;
        short   dataformat2ind;
    EXEC SQL END DECLARE SECTION;

    storageid2 = myOId.getCounter();

    if (supportsTileConfiguration())
    {
        domainid2ind = 0;
        tileConfiguration->setPersistent(true);
        domainid2 = tileConfiguration->getOId().getCounter();
    }
    else
    {
        domainid2ind = -1;
    }

    if (supportsTileSize())
    {
        tilesize2ind = 0;
        tilesize2 = tileSize;
    }
    else
    {
        tilesize2ind = -1;
    }

    if (supportsIndexSize())
    {
        indexsize2ind = 0;
        indexsize2 = indexSize;
    }
    else
    {
        indexsize2ind = -1;
    }

    if (supportsPCTMin())
    {
        pctmin2ind = 0;
        pctmin2 = pctMin;
    }
    else
    {
        pctmin2ind = -1;
    }

    if (supportsPCTMax())
    {
        pctmax2ind = 0;
        pctmax2 = pctMax;
    }
    else
    {
        pctmax2ind = -1;
    }

    if (supportsIndexType())
    {
        indextype2ind = 0;
        indextype2 = indexType;
    }
    else
    {
        indextype2ind = -1;
    }

    if (supportsTilingScheme())
    {
        tilingscheme2ind = 0;
        tilingscheme2 = tilingScheme;
    }
    else
    {
        tilingscheme2ind = -1;
    }

    if (supportsDataFormat())
    {
        dataformat2ind = 0;
        dataformat2 = dataFormat;
    }
    else
    {
        dataformat2ind = -1;
    }

    EXEC SQL INSERT
       INTO
        RAS_STORAGE
        (
        StorageId,
        DomainId,
        TileSize,
        PCTMin,
        PCTMax,
        IndexType,
        TilingScheme,
        DataFormat,
        IndexSize
        )
       VALUES   (
        :storageid2,
        :domainid2 INDICATOR :domainid2ind,
        :tilesize2 INDICATOR :tilesize2ind,
        :pctmin2 INDICATOR :pctmin2ind,
        :pctmax2 INDICATOR :pctmax2ind,
        :indextype2 INDICATOR :indextype2ind,
        :tilingscheme2 INDICATOR :tilingscheme2ind,
        :dataformat2 INDICATOR :dataformat2ind,
        :indexsize2 INDICATOR :indexsize2ind
        );
    if (SQLCODE != SQLOK)
    {
        check("DBStorageLayout::insertInDb() INSERT INTO RAS_STORAGE");
        generateException();
    }

    DBObject::insertInDb();
}

void
DBStorageLayout::deleteFromDb()
{
    EXEC SQL BEGIN DECLARE SECTION;
        long    storageid3;
    EXEC SQL END DECLARE SECTION;

    storageid3 = myOId.getCounter();

    EXEC SQL DELETE FROM RAS_STORAGE WHERE StorageId = :storageid3;
    if (SQLCODE != SQLOK)
    {
        check("DBStorageLayout::deleteFrom() DELETE FROM RAS_STORAGE");
        generateException();
    }

    tileConfiguration->setPersistent(false);
    DBObject::deleteFromDb();
}
