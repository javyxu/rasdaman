/*
* This file is part of rasdaman community.
*
* Rasdaman community is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* Rasdaman community is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with rasdaman community.  If not, see <http://www.gnu.org/licenses/>.
*
* Copyright 2003, 2004, 2005, 2006, 2007, 2008, 2009 Peter Baumann /
rasdaman GmbH.
*
* For more information please see <http://www.rasdaman.org>
* or contact Peter Baumann via <baumann@rasdaman.com>.
*/
// This is -*- C++ -*-
/*************************************************************************
 *
 *
 * PURPOSE:
 * Code with embedded SQL for PostgreSQL DBMS
 *
 *
 * COMMENTS:
 * - need connection via ECPG and libqg, use non-public interface to
 *   obtain libpq style connection ptr from ECPG structure
 * - global variable globalConnectId used for DB server identification, maybe better as constructor parameter
 * - dbName parameter not evaluated
 * - PG: no CLUSTER index available
 * - PG: index always in same schema as table
 * - replaced "if ((SQLCODE != SQLOK) && (SQLCODE != SQLNULLFETCHED))"
 *   by       "if (SQLCODE < 0 || SQLCODE == SQLNODATAFOUND)"
 * - databaseExists() not used
 *   to avoid PG name clash with attr type
 * - except for RAS_COUNTERS, "no data" means no error, but that we need to initialize the empty table
 *
 ***********************************************************************/

#include <iostream>
#include <stdlib.h>
#include <string.h>
#include "config.h"
#include "version.h"
#include "debug/debug.hh"
#include <logging.hh>

using namespace std;

// general embedded SQL related definitions
EXEC SQL include sqlglobals.h;

// SQL error codes:
EXEC SQL include "externs.h"

// PG stuff
#include "libpq-fe.h"   // C interface to PgSQL
// libq-style connection ptr taken from ECPG connect (needed for libq functions):
// (currently used by relblobif/blobtile.pgc)
PGconn *pgConn = NULL;

#include "databaseif.hh"
#include "raslib/rmdebug.hh"
#include "sqlerror.hh"
#include "oidif.hh"
#include "adminif.hh"

extern char globalConnectId[256];
extern char globalDbUser[256];
extern char globalDbPasswd[256];

// size of ARCHITECTURE attribute in RAS_ADMIN:
#define SIZE_ARCH_RASADMIN 20


void
DatabaseIf::disconnect()
{
    LDEBUG << "EXEC SQL ROLLBACK WORK";
    EXEC SQL ROLLBACK WORK;
    // 'ok' or 'no begin work issued' (which happens at a close database)
    if (SQLCODE != SQLOK && SQLCODE != -255)
    {
        check("DatabaseIf::disconnect() ROLLBACK\0");
        LERROR << "Error while issuing ROLLBACK";
    }

    LDEBUG << "EXEC SQL DISCONNECT CURRENT";
    EXEC SQL DISCONNECT rasdaConn;
    if (SQLCODE != SQLOK)
    {
        check("DatabaseIf::disconnect() DISCONNECT\0");
        LERROR << "Error while issuing DISCONNECT";
    }

    LDEBUG << "PQfinish...";
    PQfinish(pgConn);
    pgConn = NULL;
    LDEBUG << "pgConn NULL now, status: PQstatus(pgConn)=" + PQstatus(pgConn);
}

void
DatabaseIf::connect()
{
    EXEC SQL BEGIN DECLARE SECTION;
        char    id[STRING_MAXLEN];
        char    user[STRING_MAXLEN];
        char    passwd[STRING_MAXLEN];
    EXEC SQL END DECLARE SECTION;

    strcpy((char *)&id, globalConnectId);
    strcpy((char *)&user, globalDbUser);
    strcpy((char *)&passwd, globalDbPasswd);

    //LDEBUG <<"user " << globalDbUser << ", pass: " << globalDbPasswd;

    if (strlen(globalDbUser) > 0)
    {
        if (strlen(globalDbPasswd) > 0)
        {
            LDEBUG << "EXEC SQL CONNECT TO " << id << " USER " << globalDbUser << " USING ***********";
            EXEC SQL CONNECT TO :id AS rasdaConn USER :user USING :passwd;
        }
        else
        {
            LDEBUG << "EXEC SQL CONNECT TO " << id << " USER " << globalDbUser;
            EXEC SQL CONNECT TO :id AS rasdaConn USER :user;
        }
    }
    else
    {
        LDEBUG << "EXEC SQL CONNECT TO " << id;
        EXEC SQL CONNECT TO :id AS rasdaConn;       // "AS" param must be same as down in ECPGget_connection()
    }
    if (SQLCODE != SQLOK)
    {
        check("DatabaseIf::connect() CONNECT");
        LTRACE << "connect() SQLCODE=" << SQLCODE;
        LDEBUG << "error in connect, SQLCODE=" << SQLCODE;
        generateException();
    }

    // FIXME: Alan: added check to separate host from dbname, complete parsing of connectid should be implemented
    char *parsed_host = (char *)malloc(sizeof(char)*STRING_MAXLEN);
    char parsed_dbname[STRING_MAXLEN] = "";

    if ( NULL != strstr(globalConnectId,"@") )
    {
        char *safeTokenizer=(char*)malloc(sizeof(char)*STRING_MAXLEN);
        strncpy(safeTokenizer,globalConnectId,STRING_MAXLEN - 1);

        char *tokenAt=strtok(safeTokenizer, "@");
        strncpy(parsed_dbname,tokenAt,STRING_MAXLEN - 1);
        tokenAt=strtok(NULL, "@");
        strncpy(parsed_host,tokenAt,STRING_MAXLEN - 1);
        // TODO: Alan - Parse port
        free( safeTokenizer);
    }
    else
    {
        free(parsed_host);
        parsed_host=NULL;
        strncpy(parsed_dbname,globalConnectId,STRING_MAXLEN - 1);
    }
    

    if (strlen(globalDbUser) > 0)
    {
        if (strlen(globalDbPasswd) > 0)
            pgConn = PQsetdbLogin(parsed_host,NULL,NULL,NULL,parsed_dbname,globalDbUser,globalDbPasswd);
        else
            pgConn = PQsetdbLogin(parsed_host,NULL,NULL,NULL,parsed_dbname,globalDbUser,NULL);
    }
    else
    {
        pgConn = PQsetdb(parsed_host,NULL,NULL,NULL,parsed_dbname);
    }
    if (parsed_host != NULL) { free (parsed_host); }
    if (pgConn == NULL || PQstatus(pgConn) == CONNECTION_BAD)
    {
        LTRACE << "Error: cannot obtain libpq connection";
        LDEBUG << "Error: cannot obtain libpq connection";
        generateException();
    }
}

void
DatabaseIf::checkCompatibility()
{
    EXEC SQL BEGIN DECLARE SECTION;
        long rasver1;               // rasdaman version as stored in db
        long schemaver1;            // schema version as stored in db
        char* arch1[SIZE_ARCH_RASADMIN];    // used for reading architecture from db
        const char *myArchitecture = RASARCHITECTURE; // used for architecture selection
    EXEC SQL END DECLARE SECTION;

    LDEBUG << "EXEC SQL SELECT ServerVersion, IFVersion INTO :rasver1, :schemaver1 FROM RAS_ADMIN WHERE Architecture = " << myArchitecture;
    EXEC SQL SELECT
        ServerVersion, IFVersion
       INTO
        :rasver1, :schemaver1
       FROM
        RAS_ADMIN
       WHERE
        Architecture = :myArchitecture;
    LDEBUG << "-> rasver1=" << rasver1 << ", schemaver1=" << schemaver1;
    if (SQLCODE != SQLOK)
    {
        check("DatabaseIf::baseDBMSOpen() check schema\0");
        // this error is not supported by PG -- PB 2005-jan-07
        // if (SQLCODE == SQLTABLEUNKNOWN)...

        if (SQLCODE == SQLNODATAFOUND)
        {
            LERROR << "The Database is incompatible with the current RasServer./n" \
                           << "Database has no entry for the current platform./n" \
                           << "You are using rasserver:/n" \
                           << "\tversion	" << RMANVERSION <<"\n" \
                           << "\tschema	" << RASSCHEMAVERSION << "\n" \
                           << "\tplatform " << RASARCHITECTURE;
            EXEC SQL DECLARE admincursor CURSOR FOR
            SELECT
            ServerVersion, IFVersion, Architecture
            FROM
            RAS_ADMIN;
            EXEC SQL OPEN admincursor;
            do
            {
                (void) memset( arch1, '\0', (size_t) sizeof(arch1) );   // just to make sure string is terminated
                EXEC SQL FETCH admincursor INTO :rasver1, :schemaver1, :arch1;
                if (SQLCODE != SQLOK)
                {
                    if (SQLCODE != SQLNODATAFOUND)
                    {
                        check("DatabaseIf::checkCompatibility()\0");
                        LERROR << "DBMS Error occured during compatibility check.\n" \
                                       << "Please see Debug Log for additional information.";
                        EXEC SQL CLOSE admincursor;
                        generateException();
                    }
                    break;
                }
                LINFO << "Found database entries for rasserver:\n" \
                               << "\tversion	" << rasver1 << "\n" \
                               << "\tschema	" << schemaver1 << "\n" \
                               << "\tplatform " << arch1 << "\n\n" \
                               << "Please see Migration Documentation.";
            }
            while (true);

            EXEC SQL CLOSE admincursor;
            throw r_Error(DATABASE_INCOMPATIBLE);
        }
        else
        {
            LERROR << "DBMS Error occured during compatibility check.\n" \
                           << "Please see Debug Log for additional information.";
            generateException();
        }
    }
    else
    {
        if (schemaver1 != RASSCHEMAVERSION)
        {
            LFATAL << "The Database is incompatible with the current RasServer.\n" \
                           << "The database was generated with:\n" \
                           << "\tversion	" << rasver1 << "\n" \
                           << "\tschema	" << schemaver1 << "\n" \
                           << "\tplatform " << arch1 << "\n\n" \
                           << "You are using rasserver:" << "\n" \
                           << "\tversion	" << RMANVERSION << "\n" \
                           << "\tschema	" << RASSCHEMAVERSION << "\n" \
                           << "\tplatform " << RASARCHITECTURE << "\n" \
                           << "Please see Migration Documentation.";
            throw r_Error(DATABASE_INCOMPATIBLE);
        }
#if 0 // do not check against release, v6 has same schema as v5! -- PB 2005-sep-18
        // check only against major release number -- PB 2003-sep-08
        if (rasver1/1000 != DatabaseIf::rmanverToLong()/1000)
        {
            LFATAL << "The Database is incompatible with the current RasServer.\n" \
                           << "The database was generated with:\n" \
                           << "\tversion	" << rasver1 << "\n" \
                           << "\tschema	" << schemaver1 << "\n" \
                           << "\tplatform " << arch1 << "\n\n" \
                           << "You are using rasserver:\n" \
                           << "\tversion	" << RMANVERSION << "\n" \
                           << "\tschema	" << RASSCHEMAVERSION << "\n" \
                           << "\tplatform " << RASARCHITECTURE << "\n" \
                           << "Please see Migration Documentation.";
            throw r_Error(DATABASE_INCOMPATIBLE);
        }
#endif // 0
    }
}

bool
DatabaseIf::isConsistent()
{
    bool retval=true;

    EXEC SQL BEGIN DECLARE SECTION;
        long    nextoid;
        long    checkoid;   // was: double -- PB 2005-jul-12
        short   oidind;
        char    name2[255]; // must be able to hold counterNames elements, see oidif.cc
    EXEC SQL END DECLARE SECTION;
    nextoid = 0;
    checkoid = 0;
    oidind = 0;

    (void) strncpy( name2, const_cast<char*>(OId::counterNames[OId::DBMINTERVALOID]), (size_t) sizeof(name2) );
    LDEBUG << "EXEC SQL SELECT NextValue INTO :nextoid FROM RAS_COUNTERS WHERE CounterName = " << name2;
    EXEC SQL SELECT NextValue INTO :nextoid
       FROM
        RAS_COUNTERS
       WHERE
        CounterName = :name2;
    LDEBUG << "-> nextoid=" << nextoid;
    if (check("DatabaseIf::isConsistent() SELECT DBMINTERVALOID"))
        generateException();

    // replaced MAX() (which ignores index) by ORDER BY variant -- PB 2005-jul-12
    // EXEC SQL SELECT MAX(DomainId) INTO :checkoid INDICATOR :oidind
    //  FROM RAS_DOMAINS;
    checkoid = 0;
    LDEBUG << "SELECT DomainId...";
    EXEC SQL SELECT DomainId INTO :checkoid INDICATOR :oidind
       FROM RAS_DOMAINS
       ORDER BY DomainId DESC LIMIT 1;
    LDEBUG << "-> SQLCODE=" << SQLCODE;
    // now "no data" means no error, but that we need to initialize the empty table
    if (SQLCODE < 0)
    {
        check("DatabaseIf::isConsistent() SELECT MAX(DomainId)");
        generateException();
    }
    if ((checkoid > nextoid) && (oidind == 0))
    {
        LERROR << "The administrative tables for Domain Data is inconsistent.	Please call support.";
        LTRACE << "Counter in RAS_DOMAINS : " << checkoid << "\n" << "Counter in RAS_COUNTERS : " << nextoid;
        retval=false;
    }
    checkoid = 0;
    nextoid=0;
    oidind=0;

    if(retval)
    {
        (void) strncpy( name2, const_cast<char*>(OId::counterNames[OId::MDDOID]), (size_t) sizeof(name2) );
        LDEBUG << "SELECT NextValue FROM RAS_COUNTERS...";
        EXEC SQL SELECT NextValue INTO :nextoid
        FROM RAS_COUNTERS
        WHERE CounterName = :name2;
        if (check("DatabaseIf::isConsistent() SELECT MDDOID"))
            generateException();
        // replaced MAX() (which ignores index) by ORDER BY variant -- PB 2005-jul-12
        // EXEC SQL SELECT MAX(MDDId) INTO :checkoid INDICATOR :oidind
        //  FROM RAS_MDDOBJECTS;
        checkoid = 0;
        LDEBUG << "SELECT MDDId FROM RAS_MDDOBJECTS...";
        EXEC SQL SELECT MDDId INTO :checkoid INDICATOR :oidind
        FROM RAS_MDDOBJECTS
        ORDER BY MDDId DESC LIMIT 1;
        // now "no data" means no error, but that we need to initialize the empty table
        if (SQLCODE < 0)
        {
            check("DatabaseIf::isConsistent() SELECT MAX(MDDId)");
            generateException();
        }

        if ((checkoid > nextoid) && (oidind == 0))
        {
            LERROR << "The administrative tables for MDD Objects is inconsistent.	Please call support.";
            LTRACE << "Counter in RAS_MDDOBJECTS : " << checkoid << "\n" << "Counter in RAS_COUNTERS : " << nextoid;
            retval=false;
        }
        checkoid = 0;
        nextoid=0;
        oidind=0;
    }

    if(retval)
    {
        (void) strncpy( name2, const_cast<char*>(OId::counterNames[OId::MDDCOLLOID]), (size_t) sizeof(name2) );
        EXEC SQL SELECT NextValue INTO :nextoid
        FROM RAS_COUNTERS
        WHERE CounterName = :name2;
        if (check("DatabaseIf::isConsistent() SELECT MDDCollOId"))
            generateException();
        // replaced MAX() (which ignores index) by ORDER BY variant -- PB 2005-jul-12
        // EXEC SQL SELECT MAX(MDDCollId) INTO :checkoid INDICATOR :oidind
        //  FROM RAS_MDDCOLLNAMES;
        checkoid = 0;
        LDEBUG << "SELECT MDDCollId FROM RAS_MDDCOLLNAMES...";
        EXEC SQL SELECT MDDCollId INTO :checkoid INDICATOR :oidind
        FROM RAS_MDDCOLLNAMES
        ORDER BY MDDCollId DESC LIMIT 1;
        // now "no data" means no error, but that we need to initialize the empty table
        if (SQLCODE < 0)
        {
            check("DatabaseIf::isConsistent() SELECT MAX(MDDCollId)");
            generateException();
        }

        if ((checkoid > nextoid) && (oidind == 0))
        {
            LERROR << "The administrative tables for MDD Collections is inconsistent.	Please call support.";
            LTRACE << "Counter in RAS_MDDCOLLNAMES : " << checkoid << "\n" << "Counter in RAS_COUNTERS : " << nextoid;
            retval=false;
        }
        checkoid = 0;
        nextoid=0;
        oidind=0;
    }

    if(retval)
    {
        (void) strncpy( name2, const_cast<char*>(OId::counterNames[OId::MDDTYPEOID]), (size_t) sizeof(name2) );
        EXEC SQL SELECT NextValue INTO :nextoid
        FROM RAS_COUNTERS
        WHERE CounterName = :name2;
        if (check("DatabaseIf::isConsistent() SELECT MDDTYPEOID"))
            generateException();
        // replaced MAX() (which ignores index) by ORDER BY variant -- PB 2005-jul-12
        // EXEC SQL SELECT MAX(MDDTypeOId) INTO :checkoid INDICATOR :oidind
        //  FROM RAS_MDDTYPES;
        checkoid = 0;
        LDEBUG << "SELECT MDDTypeOId FROM RAS_MDDTYPES...";
        EXEC SQL SELECT MDDTypeOId INTO :checkoid INDICATOR :oidind
        FROM RAS_MDDTYPES
        ORDER BY MDDTypeOId DESC LIMIT 1;
        LDEBUG << "SELECT MDDTypeOId FROM RAS_MDDTYPES...";
        // now "no data" means no error, but that we need to initialize the empty table
        if (SQLCODE < 0)
        {
            check("DatabaseIf::isConsistent() SELECT MAX(MDDTypeOId)");
            generateException();
        }

        if (checkoid > nextoid)
        {
            LERROR << "The administrative tables for MDDTypes is inconsistent.	Please call support.";
            LTRACE << "Counter in RAS_MDDTYPES : " << checkoid << "\n" << "Counter in RAS_COUNTERS : " << nextoid << " real " << nextoid;
            retval=false;
        }
        checkoid = 0;
        nextoid=0;
        oidind=0;
    }

    if(retval)
    {
        (void) strncpy( name2, const_cast<char*>(OId::counterNames[OId::MDDBASETYPEOID]), (size_t) sizeof(name2) );
        EXEC SQL SELECT NextValue INTO :nextoid
        FROM RAS_COUNTERS
        WHERE CounterName = :name2;
        if (check("DatabaseIf::isConsistent() SELECT MDDBASETYPEOID"))
            generateException();
        // replaced MAX() (which ignores index) by ORDER BY variant -- PB 2005-jul-12
        // EXEC SQL SELECT MAX(MDDBaseTypeOId) INTO :checkoid INDICATOR :oidind
        //  FROM RAS_MDDBASETYPES;
        checkoid = 0;
        LDEBUG << "SELECT MDDBaseTypeOId FROM RAS_MDDBASETYPES...";
        EXEC SQL SELECT MDDBaseTypeOId INTO :checkoid INDICATOR :oidind
        FROM RAS_MDDBASETYPES
        ORDER BY MDDBaseTypeOId DESC LIMIT 1;
        // now "no data" means no error, but that we need to initialize the empty table
        if (SQLCODE < 0)
        {
            check("DatabaseIf::isConsistent() SELECT MAX(MDDBaseTypeOId)");
            generateException();
        }

        if (checkoid > nextoid)
        {
            LERROR << "The administrative tables for MDDBaseTypes is inconsistent.	Please call support.";
            LTRACE << "Counter in RAS_MDDBASETYPES : " << checkoid << "\n" << "Counter in RAS_COUNTERS : " << nextoid << " real " << nextoid;
            retval=false;
        }
        checkoid = 0;
        nextoid=0;
        oidind=0;
    }

    if(retval)
    {
        (void) strncpy( name2, const_cast<char*>(OId::counterNames[OId::MDDDIMTYPEOID]), (size_t) sizeof(name2) );
        EXEC SQL SELECT NextValue INTO :nextoid
        FROM RAS_COUNTERS
        WHERE CounterName = :name2;
        if (check("DatabaseIf::isConsistent() SELECT MDDDIMTYPEOID"))
            generateException();
        // replaced MAX() (which ignores index) by ORDER BY variant -- PB 2005-jul-12
        // EXEC SQL SELECT MAX(MDDDimTypeOId) INTO :checkoid INDICATOR :oidind
        //  FROM RAS_MDDDIMTYPES;
        checkoid = 0;
        LDEBUG << "SELECT MDDDimTypeOId FROM RAS_MDDDIMTYPES...";
        EXEC SQL SELECT MDDDimTypeOId INTO :checkoid INDICATOR :oidind
        FROM RAS_MDDDIMTYPES
        ORDER BY MDDDimTypeOId DESC LIMIT 1;
        // now "no data" means no error, but that we need to initialize the empty table
        if (SQLCODE < 0)
        {
            check("DatabaseIf::isConsistent() SELECT MAX(MDDDimTypeOId)");
            generateException();
        }

        if (checkoid > nextoid)
        {
            LERROR << "The administrative tables for MDDDimensionTypes is inconsistent.	Please call support.";
            LTRACE << "Counter in RAS_MDDDIMTYPES : " << checkoid << "\n" << "Counter in RAS_COUNTERS : " << nextoid << " real " << nextoid;
            retval=false;
        }
        checkoid = 0;
        nextoid=0;
        oidind=0;
    }

    if(retval)
    {
        (void) strncpy( name2, const_cast<char*>(OId::counterNames[OId::MDDDOMTYPEOID]), (size_t) sizeof(name2) );
        EXEC SQL SELECT NextValue INTO :nextoid
        FROM RAS_COUNTERS
        WHERE CounterName = :name2;
        if (check("DatabaseIf::isConsistent() SELECT MDDDOMTYPEOID"))
            generateException();
        // replaced MAX() (which ignores index) by ORDER BY variant -- PB 2005-jul-12
        // EXEC SQL SELECT MAX(MDDDomTypeOId) INTO :checkoid INDICATOR :oidind
        //  FROM RAS_MDDDOMTYPES;
        checkoid = 0;
        LDEBUG << "SELECT MDDDomTypeOId FROM RAS_MDDDOMTYPES...";
        EXEC SQL SELECT MDDDomTypeOId INTO :checkoid INDICATOR :oidind
        FROM RAS_MDDDOMTYPES
        ORDER BY MDDDomTypeOId DESC LIMIT 1;
        // now "no data" means no error, but that we need to initialize the empty table
        if (SQLCODE < 0)
        {
            check("DatabaseIf::isConsistent() SELECT MAX(MDDDomTypeId)");
            generateException();
        }

        if (checkoid > nextoid)
        {
            LERROR << "The administrative tables for MDDDomainTypes is inconsistent.	Please call support.";
            LTRACE << "Counter in RAS_MDDDOMTYPES : " << checkoid << "\n" << "Counter in RAS_COUNTERS : " << nextoid << " real " << nextoid;
            retval=false;
        }
        checkoid = 0;
        nextoid=0;
        oidind=0;
    }

    if(retval)
    {
        (void) strncpy( name2, const_cast<char*>(OId::counterNames[OId::STRUCTTYPEOID]), (size_t) sizeof(name2) );
        EXEC SQL SELECT NextValue INTO :nextoid
        FROM RAS_COUNTERS
        WHERE CounterName = :name2;
        if (check("DatabaseIf::isConsistent() SELECT STRUCTTYPEOID"))
            generateException();
        // replaced MAX() (which ignores index) by ORDER BY variant -- PB 2005-jul-12
        // EXEC SQL SELECT MAX(BaseTypeId) INTO :checkoid INDICATOR :oidind
        //  FROM RAS_BASETYPENAMES;
        checkoid = 0;
        LDEBUG << "SELECT BaseTypeId FROM RAS_BASETYPENAMES...";
        EXEC SQL SELECT BaseTypeId INTO :checkoid INDICATOR :oidind
        FROM RAS_BASETYPENAMES
        ORDER BY BaseTypeId DESC LIMIT 1;
        // now "no data" means no error, but that we need to initialize the empty table
        if (SQLCODE < 0)
        {
            check("DatabaseIf::isConsistent() SELECT MAX(BaseTypeId)");
            generateException();
        }

        if ((checkoid > nextoid) && (oidind == 0))
        {
            LERROR << "The administrative tables for StructTypes is inconsistent.	Please call support.";
            LTRACE << "Counter in RAS_BASETYPENAMES : " << checkoid << "\n" << "Counter in RAS_COUNTERS : " << nextoid;
            retval=false;
        }
        checkoid = 0;
        nextoid=0;
        oidind=0;
    }

    if(retval)
    {
        (void) strncpy( name2, const_cast<char*>(OId::counterNames[OId::SETTYPEOID]), (size_t) sizeof(name2) );
        EXEC SQL SELECT NextValue INTO :nextoid
        FROM RAS_COUNTERS
        WHERE CounterName = :name2;
        if (check("DatabaseIf::isConsistent() SELECT SETTYPEOID"))
            generateException();
        // replaced MAX() (which ignores index) by ORDER BY variant -- PB 2005-jul-12
        // EXEC SQL SELECT MAX(SetTypeId) INTO :checkoid INDICATOR :oidind
        //  FROM RAS_SETTYPES;
        checkoid = 0;
        LDEBUG << "SELECT SetTypeId FROM RAS_SETTYPES...";
        EXEC SQL SELECT SetTypeId INTO :checkoid INDICATOR :oidind
        FROM RAS_SETTYPES
        ORDER BY SetTypeId DESC LIMIT 1;
        // now "no data" means no error, but that we need to initialize the empty table
        if (SQLCODE < 0)
        {
            check("DatabaseIf::isConsistent() SELECT MAX(SetTypeId)");
            generateException();
        }

        if ((checkoid > nextoid) && (oidind == 0))
        {
            LERROR << "The administrative tables for MDDTypes is inconsistent.	Please call support.";
            LTRACE << "Counter in RAS_SETTYPES : " << checkoid << "\n" << "Counter in RAS_COUNTERS : " << nextoid;
            retval=false;
        }
        checkoid = 0;
        nextoid=0;
        oidind=0;
    }

    if(retval)
    {
        (void) strncpy( name2, const_cast<char*>(OId::counterNames[OId::BLOBOID]), (size_t) sizeof(name2) );
        EXEC SQL SELECT NextValue INTO :nextoid
        FROM RAS_COUNTERS
        WHERE CounterName = :name2;
        if (check("DatabaseIf::isConsistent() SELECT BLOBOID"))
            generateException();
        // replaced MAX() (which ignores index) by ORDER BY variant -- PB 2005-jul-12
        // EXEC SQL SELECT MAX(BlobId) INTO :checkoid INDICATOR :oidind
        //  FROM RAS_TILES;
        checkoid = 0;
        LDEBUG << "SELECT BlobId FROM RAS_TILES...";
        EXEC SQL SELECT BlobId INTO :checkoid INDICATOR :oidind
        FROM RAS_TILES
        ORDER BY BlobId DESC LIMIT 1;
        // now "no data" means no error, but that we need to initialize the empty table
        if (SQLCODE < 0)
        {
            check("DatabaseIf::isConsistent() SELECT MAX(BlobId)");
            generateException();
        }

        if ((checkoid > nextoid) && (oidind == 0))
        {
            LERROR << "The administrative tables for BLOB Data is inconsistent.	Please call support.";
            LTRACE << "Counter in RAS_TILES : " << checkoid << "\n" << "Counter in RAS_COUNTERS : " << nextoid;
            retval=false;
        }
        checkoid = 0;
        nextoid=0;
        oidind=0;
    }

    if(retval)
    {
        (void) strncpy( name2, const_cast<char*>(OId::counterNames[OId::MDDHIERIXOID]), (size_t) sizeof(name2) );
        EXEC SQL SELECT NextValue INTO :nextoid
        FROM RAS_COUNTERS
        WHERE CounterName = :name2;
        if (check("DatabaseIf::isConsistent() SELECT MDDHIERIXOID"))
            generateException();
        // replaced MAX() (which ignores index) by ORDER BY variant -- PB 2005-jul-12
        // EXEC SQL SELECT MAX(MDDObjIxOId) INTO :checkoid INDICATOR :oidind
        //  FROM RAS_HIERIX;
        checkoid = 0;
        LDEBUG << "SELECT MDDObjIxOId FROM RAS_HIERIX...";
        EXEC SQL SELECT MDDObjIxOId INTO :checkoid INDICATOR :oidind
        FROM RAS_HIERIX
        ORDER BY MDDObjIxOId DESC LIMIT 1;
        // now "no data" means no error, but that we need to initialize the empty table
        if (SQLCODE < 0)
        {
            check("DatabaseIf::isConsistent() SELECT MAX(MDDObjIxOId)");
            generateException();
        }

        if (checkoid > (nextoid * 512 + OId::MDDHIERIXOID))
        {
            LERROR << "The administrative tables for hierarchical MDD indexes is inconsistent.	Please call support.";
            LTRACE << "Counter in RAS_HIERIX : " << checkoid << "\n" << "Counter in RAS_COUNTERS : " << nextoid << " real " << (nextoid * 512 + OId::MDDHIERIXOID);
            retval=false;
        }
        checkoid = 0;
        nextoid=0;
        oidind=0;
    }

    if(retval)
    {
        (void) strncpy( name2, const_cast<char*>(OId::counterNames[OId::STORAGEOID]), (size_t) sizeof(name2) );
        EXEC SQL SELECT NextValue INTO :nextoid
        FROM RAS_COUNTERS
        WHERE CounterName = :name2;
        if (check("DatabaseIf::isConsistent() SELECT STORAGEOID"))
            generateException();
        // replaced MAX() (which ignores index) by ORDER BY variant -- PB 2005-jul-12
        // EXEC SQL SELECT MAX(StorageId) INTO :checkoid INDICATOR :oidind
        //  FROM RAS_STORAGE;
        checkoid=0;
        LDEBUG << "SELECT StorageId FROM RAS_STORAGE...";
        EXEC SQL SELECT StorageId INTO :checkoid INDICATOR :oidind
        FROM RAS_STORAGE
        ORDER BY StorageId DESC LIMIT 1;
        // now "no data" means no error, but that we need to initialize the empty table
        if (SQLCODE < 0)
        {
            check("DatabaseIf::isConsistent() SELECT MAX(StorageId)");
            generateException();
        }

        if ((checkoid > nextoid) && (oidind == 0))
        {
            LERROR << "Fatal error: administrative tables for MDD storage structures are inconsistent.	Please call support.";
            LTRACE << "Counter in RAS_STORAGE : " << checkoid << "\n" << "Counter in RAS_COUNTERS : " << nextoid;
            retval=false;
        }
        checkoid=0;
        nextoid=0;
        oidind=0;
    }

    return retval;
}

void
DatabaseIf::createDB( const char* dbName, const char* schemaName,  const char* volumeName)
{
    unsigned int i=0;
    EXEC SQL BEGIN DECLARE SECTION;
        long id;
        long idd;
        char name[255];
    EXEC SQL END DECLARE SECTION;

    name[0] = '\0';     // initialize to empty string

    try
    {
        if (AdminIf::getCurrentDatabaseIf() != 0)
        {
            LTRACE << "another database is open";
            LDEBUG << "Error: another database is open";
            throw r_Error(r_Error::r_Error_DatabaseOpen);
        }
        connect();
        LDEBUG << "EXEC SQL BEGIN WORK;";
        EXEC SQL BEGIN WORK;
        if(check("DatabaseIf::create() BEGIN WORK\0"))
            generateException();

        /* not used, see comment with databaseExists()
                // does database exist already?
                if (databaseExists(dbName))
                {
                    LTRACE << "database already exists";
                    LFATAL << "Database creation failed: database exists already.";
                    LDEBUG << "Error: database exists.";
                    throw r_Error(DATABASE_EXISTS);
                }
        */

        // --- start table/index creation ------------------------------

        // no index here because there is only one entry in the table
        LDEBUG << "EXEC SQL CREATE TABLE RAS_ADMIN ( IFVersion INTEGER NOT NULL, Architecture VARCHAR(20) NOT NULL, ServerVersion INTEGER NOT NULL) ";
        EXEC SQL CREATE TABLE RAS_ADMIN (
        IFVersion INTEGER NOT NULL,
        Architecture VARCHAR(20) NOT NULL,
        ServerVersion INTEGER NOT NULL
        );
        if(check("DatabaseIf::create() CREATE TABLE RAS_ADMIN\0"))
            generateException();

        id = RASSCHEMAVERSION;
        idd = DatabaseIf::rmanverToLong();
        (void) strncpy( name, RASARCHITECTURE, (size_t) sizeof(name) );

        LDEBUG << "EXEC SQL INSERT INTO RAS_ADMIN (IFVersion, Architecture, ServerVersion) VALUES (" << id << ", " << name << ", " << idd << ")";
        EXEC SQL INSERT INTO RAS_ADMIN (IFVersion, Architecture, ServerVersion) VALUES (:id, :name, :idd);
        if(check("DatabaseIf::create() INSERT INTO RAS_ADMIN\0"))
            generateException();

        // no index here because there is only 20 entries in the table
        LDEBUG << "EXEC SQL CREATE TABLE RAS_COUNTERS ( NextValue INTEGER NOT NULL, CounterName VARCHAR(20) NOT NULL)";
        EXEC SQL CREATE TABLE RAS_COUNTERS (
        NextValue INTEGER NOT NULL,
        CounterName VARCHAR(20) NOT NULL
        );
        if(check("DatabaseIf::create() CREATE TABLE RAS_COUNTERS\0"))
            generateException();

        // initialising RAS_COUNTERS
        for(i = 1; i < OId::maxCounter; i++)
        {
            (void) strncpy( name, const_cast<char*>(OId::counterNames[i]), (size_t) sizeof(name) );
            id = 1;
            LDEBUG << "EXEC SQL INSERT INTO RAS_COUNTERS (CounterName, NextValue) VALUES (" << name << "," << id << ")";
            EXEC SQL INSERT INTO RAS_COUNTERS (CounterName, NextValue) VALUES (:name, :id);
            if(check("DatabaseIf::create() INSERT INTO RAS_COUNTERS\0"))
                generateException();
        }

        LDEBUG << "...and several more tables...";

        // relblobif
        EXEC SQL CREATE TABLE RAS_TILES (
        BlobId BIGINT NOT NULL,
        DataFormat INTEGER,
        Tile BIGINT
        );
        if(check("DatabaseIf::create() CREATE TABLE RAS_TILES\0"))
            generateException();

        EXEC SQL CREATE UNIQUE INDEX RAS_TILES_IX
        ON RAS_TILES (BlobId);
        if(check("DatabaseIf::create() CREATE UNIQUE INDEX RAS_TILES_IX\0"))
            generateException();

        //ras_itiles
        EXEC SQL CREATE TABLE RAS_ITILES (
        ITileId BIGINT NOT NULL,
        ITile BIGINT
        );
        if (check("DatabaseIf::create() CREATE TABLE RAS_ITILES\0"))
            generateException();

        EXEC SQL CREATE UNIQUE INDEX RAS_ITILES_IX
        ON RAS_ITILES (ITileId);
        if(check("DatabaseIf::create() CREATE UNIQUE INDEX RAS_ITILES_IX\0"))
            generateException();

        // relcatalogif
        EXEC SQL CREATE TABLE RAS_MDDTYPES (
        MDDTypeOId BIGINT NOT NULL,
        MDDTypeName VARCHAR(254) NOT NULL
        );
        if(check("DatabaseIf::create() CREATE TABLE RAS_MDDTYPES\0"))
            generateException();

        EXEC SQL CREATE UNIQUE INDEX RAS_MDDTYPES_IX
        ON RAS_MDDTYPES (MDDTypeOId);
        if(check("DatabaseIf::create() CREATE UNIQUE INDEX RAS_MDDTYPES_IX\0"))
            generateException();

        EXEC SQL CREATE TABLE RAS_ITMAP (
        TileId BIGINT NOT NULL,
        IndexId BIGINT NOT NULL
        );
        if(check("DatabaseIf::create() CREATE TABLE RAS_ITMAP\0"))
            generateException();

        EXEC SQL CREATE UNIQUE INDEX RAS_ITMAP_IX
        ON RAS_ITMAP (TileId);
        if(check("DatabaseIf::create() CREATE UNIQUE INDEX RAS_ITMAP_IX\0"))
            generateException();

        EXEC SQL CREATE TABLE RAS_MDDBASETYPES (
        MDDBaseTypeOId BIGINT NOT NULL,
        BaseTypeId BIGINT NOT NULL,
        MDDTypeName VARCHAR(254) NOT NULL
        );
        if(check("DatabaseIf::create() CREATE TABLE RAS_MDDBASETYPES\0"))
            generateException();

        EXEC SQL CREATE UNIQUE INDEX RAS_MDDBASETYPES_IX
        ON RAS_MDDBASETYPES (MDDBaseTypeOId);
        if(check("DatabaseIf::create() CREATE UNIQUE INDEX RAS_MDDBASETYPES_IX\0"))
            generateException();

        EXEC SQL CREATE TABLE RAS_MDDDIMTYPES (
        MDDDimTypeOId BIGINT NOT NULL,
        BaseTypeId BIGINT NOT NULL,
        Dimension INTEGER NOT NULL,
        MDDTypeName VARCHAR(254) NOT NULL
        );
        if(check("DatabaseIf::create() CREATE TABLE RAS_MDDDIMTYPES\0"))
            generateException();

        EXEC SQL CREATE UNIQUE INDEX RAS_MDDDIMTYPES_IX
        ON RAS_MDDDIMTYPES (MDDDimTypeOId);
        if(check("DatabaseIf::create() CREATE UNIQUE INDEX RAS_MDDDIMTYPES_IX\0"))
            generateException();

        EXEC SQL CREATE TABLE RAS_MDDDOMTYPES (
        MDDDomTypeOId BIGINT NOT NULL,
        BaseTypeId BIGINT NOT NULL,
        DomainId INTEGER NOT NULL,
        MDDTypeName VARCHAR(254) NOT NULL
        );
        if(check("DatabaseIf::create() CREATE TABLE RAS_MDDDOMAINTYPES\0"))
            generateException();

        EXEC SQL CREATE UNIQUE INDEX RAS_MDDDOMTYPES_IX
        ON RAS_MDDDOMTYPES (MDDDomTypeOId);
        if(check("DatabaseIf::create() CREATE UNIQUE INDEX RAS_MDDDOMTYPES_IX\0"))
            generateException();

        EXEC SQL CREATE TABLE RAS_SETTYPES (
        SetTypeId INTEGER NOT NULL,
        MDDTypeOId BIGINT NOT NULL,
        SetTypeName VARCHAR(254) NOT NULL
        );
        if(check("DatabaseIf::create() CREATE TABLE RAS_SETTYPES\0"))
            generateException();

        EXEC SQL CREATE UNIQUE INDEX RAS_SETTYPES_IX
        ON RAS_SETTYPES (SetTypeId);
        if(check("DatabaseIf::create() CREATE UNIQUE INDEX RAS_SETTYPES_IX\0"))
            generateException();

        EXEC SQL CREATE TABLE RAS_BASETYPENAMES (
        BaseTypeId SMALLINT NOT NULL,
        BaseTypeName VARCHAR (254) NOT NULL
        );
        if(check("DatabaseIf::create() CREATE TABLE RAS_BASETYPENAMES\0"))
            generateException();

        /* CREATE TABLE, INDEX for the LockManager: START */
        EXEC SQL CREATE TABLE RAS_LOCKEDTILES (
            TileID bigint NOT NULL,
            RasServerID varchar(40) NOT NULL,
            SharedLock integer NOT NULL,
            ExclusiveLock integer,
            UNIQUE(TileID, ExclusiveLock)
        );
        if(check("DatabaseIf::create() CREATE TABLE RAS_LOCKEDTILES\0"))
            generateException();
        /* CREATE TABLE, INDEX for the LockManager: END */

        EXEC SQL CREATE UNIQUE INDEX RAS_BASETYPENAMES_IX
        ON RAS_BASETYPENAMES (BaseTypeId);
        if(check("DatabaseIf::create() CREATE UNIQUE INDEX RAS_BASETYPENAMES_IX\0"))
            generateException();

        EXEC SQL CREATE TABLE RAS_BASETYPES (
        BaseTypeId INTEGER NOT NULL,
        Count SMALLINT NOT NULL,
        ContentType BIGINT NOT NULL,
        ContentTypeName VARCHAR (254) NOT NULL
        );
        if(check("DatabaseIf::create() CREATE TABLE RAS_BASETYPES\0"))
            generateException();

        EXEC SQL CREATE INDEX RAS_BASETYPESC_IX
        ON RAS_BASETYPES (BaseTypeId);
        if(check("DatabaseIf::create() CREATE INDEX RAS_BASETYPES_IX\0"))
            generateException();

        EXEC SQL CREATE UNIQUE INDEX RAS_BASETYPES_IX
        ON RAS_BASETYPES (BaseTypeId, Count);
        if(check("DatabaseIf::create() CREATE UNIQUE INDEX RAS_BASETYPES_IX\0"))
            generateException();

        EXEC SQL CREATE TABLE RAS_PYRAMIDS (
        PyramidName VARCHAR(240) NOT NULL,
        CollectionName VARCHAR(240) NOT NULL,
        MDDOId VARCHAR(240) NOT NULL,
        ScaleFactor DEC NOT NULL
        );
        if(check("DatabaseIf::create() CREATE TABLE RAS_PYRAMIDS\0"))
            generateException();

        EXEC SQL CREATE TABLE RAS_DOMAINS (
        DomainId INTEGER NOT NULL,
        Dimension INTEGER NOT NULL
        );
        if(check("DatabaseIf::create() CREATE TABLE RAS_DOMAINS\0"))
            generateException();

        EXEC SQL CREATE UNIQUE INDEX RAS_DOMAINS_IX
        ON RAS_DOMAINS (DomainId);
        if(check("DatabaseIf::create() CREATE UNIQUE INDEX RAS_DOMAINS_IX\0"))
            generateException();

        EXEC SQL CREATE TABLE RAS_DOMAINVALUES (
        DomainId INTEGER NOT NULL,
        DimensionCount INTEGER NOT NULL,
        Low INTEGER,
        High INTEGER
        );
        if(check("DatabaseIf::create() CREATE TABLE RAS_DOMAINVALUES\0"))
            generateException();

        EXEC SQL CREATE INDEX RAS_DOMAINVALUESC_IX
          ON RAS_DOMAINVALUES (DomainId);
        if(check("DatabaseIf::create() CREATE INDEX RAS_DOMAINVALUESC_IX\0"))
            generateException();

        EXEC SQL CREATE UNIQUE INDEX RAS_DOMAINVALUES_IX
          ON RAS_DOMAINVALUES (DomainId, DimensionCount);
        if(check("DatabaseIf::create() CREATE UNIQUE INDEX RAS_DOMAINVALUES_IX\0"))
            generateException();

        // relmddif
        EXEC SQL CREATE TABLE RAS_MDDCOLLECTIONS (
        MDDId INTEGER NOT NULL,
        MDDCollId INTEGER NOT NULL
        );
        if(check("DatabaseIf::create() CREATE TABLE RAS_MDDCOLLECTIONS\0"))
            generateException();

        EXEC SQL CREATE INDEX RAS_COLLECTIONSC_IX
        ON RAS_MDDCOLLECTIONS (MDDCOllId);
        if(check("DatabaseIf::create() CREATE INDEX RAS_COLLECTIONSC_IX\0"))
            generateException();

        EXEC SQL CREATE UNIQUE INDEX RAS_COLLECTIONS_IX
        ON RAS_MDDCOLLECTIONS (MDDCOllId, MDDId);
        if(check("DatabaseIf::create() CREATE UNIQUE INDEX RAS_COLLECTIONS_IX\0"))
            generateException();

        // referes to MDDSet
        EXEC SQL CREATE TABLE RAS_MDDCOLLNAMES (
        MDDCollId INTEGER NOT NULL,
        SetTypeId INTEGER NOT NULL,
        MDDCollName VARCHAR(254)
        );
        if(check("DatabaseIf::create() CREATE TABLE RAS_MDDCOLLNAMES\0"))
            generateException();

        EXEC SQL CREATE UNIQUE INDEX RAS_MDDCOLLNAMES_IX
        ON RAS_MDDCOLLNAMES (MDDCollId);
        if(check("DatabaseIf::create() CREATE UNIQUE INDEX RAS_MDDCOLLNAMES_IX\0"))
            generateException();

        EXEC SQL CREATE TABLE RAS_MDDOBJECTS (
        MDDId INTEGER NOT NULL,
        BaseTypeOId BIGINT NOT NULL,
        DomainId INTEGER NOT NULL,
        PersRefCount INTEGER NOT NULL,
        StorageOId BIGINT NOT NULL,
        NodeOId BIGINT
        );
        if(check("DatabaseIf::create() CREATE TABLE RAS_MDDOBJECTS\0"))
            generateException();

        EXEC SQL CREATE UNIQUE INDEX RAS_MDDOBJECTS_IX
        ON RAS_MDDOBJECTS (MDDId);
        if(check("DatabaseIf::create() CREATE UNIQUE INDEX RAS_MDDOBJECTS_IX\0"))
            generateException();

        //relstorageif
        EXEC SQL CREATE TABLE RAS_STORAGE (
        StorageId   INTEGER NOT NULL,
        DomainId    INTEGER,
        TileSize    INTEGER,
        PCTMin      INTEGER,
        PCTMax      INTEGER,
        IndexSize   INTEGER,
        IndexType   SMALLINT,
        TilingScheme    SMALLINT,
        DataFormat  SMALLINT
        );
        if(check("DatabaseIf::create() CREATE TABLE RAS_MDDOBJECTS\0"))
            generateException();

        EXEC SQL CREATE UNIQUE INDEX RAS_STORAGE_IX
        ON RAS_STORAGE (StorageId);
        if(check("DatabaseIf::create() CREATE UNIQUE INDEX RAS_STORAGE_IX\0"))
            generateException();

        // relindexif
        // may not be needed
        EXEC SQL CREATE TABLE RAS_HIERIX (
        MDDObjIxOId BIGINT NOT NULL,
        NumEntries  INTEGER NOT NULL,
        Dimension   INTEGER NOT NULL,
        ParentOId   BIGINT NOT NULL,
        IndexSubType SMALLINT NOT NULL,
        DynData     BIGINT
        );
        if(check("DatabaseIf::create() CREATE TABLE RAS_HIERIX\0"))
            generateException();

        // <9.0: We need 1 byte more because the first character may not be a \0 -> the first byte is always 13
        // 9.0: the first 8 bytes now contain a header, does work under PG
        // note: this does not hold for PG, but we keep it to remain cross-platform consistent in data
        // note2: we use blob instead of varchar because the latter can hold only ascii data in PG
        EXEC SQL CREATE TABLE RAS_RCINDEXDYN (
        Id      BIGINT NOT NULL,
        Count   INTEGER NOT NULL,
        DynData BIGINT
        );
        if(check("DatabaseIf::create() CREATE TABLE RAS_RCINDEXDYN\0"))
            generateException();

        EXEC SQL CREATE INDEX RAS_RCINDEXDYNC_IX
        ON RAS_RCINDEXDYN (Id);
        if(check("DatabaseIf::create() CREATE INDEX RAS_RCINDEXDYNC_IX\0"))
            generateException();

        EXEC SQL CREATE UNIQUE INDEX RAS_RCINDEXDYN_IX
        ON RAS_RCINDEXDYN (Id, Count);
        if(check("DatabaseIf::create() CREATE UNIQUE INDEX RAS_RCINDEXDYN_IX\0"))
            generateException();

        EXEC SQL CREATE VIEW RAS_MDDTYPES_VIEW
          (MDDTypeOId, MDDTypeName)
        AS
          SELECT
                MDDTypeOId * 512 + 3, MDDTypeName
            FROM
                RAS_MDDTYPES
        UNION
          SELECT
                MDDBaseTypeOId * 512 + 4, MDDTypeName
            FROM
                RAS_MDDBASETYPES
        UNION
          SELECT
                MDDDimTypeOId * 512 + 5, MDDTypeName
            FROM
                RAS_MDDDIMTYPES
        UNION
          SELECT
                MDDDomTypeOId * 512 + 6, MDDTypeName
            FROM
                RAS_MDDDOMTYPES;
        if(check("DatabaseIf::create() CREATE VIEW"))
            generateException();

        // nullvalues
        EXEC SQL CREATE TABLE RAS_NULLVALUES (
          SetTypeOId BIGINT NOT NULL,
          NullValueOId BIGINT NOT NULL
        );
        if(check("DatabaseIf::create() CREATE TABLE RAS_NULLVALUES\0"))
            generateException();

        EXEC SQL CREATE UNIQUE INDEX RAS_NULLVALUES_IX
        ON RAS_NULLVALUES (SetTypeOId);
        if(check("DatabaseIf::create() CREATE UNIQUE INDEX RAS_NULLVALUES_IX\0"))
            generateException();
        
        EXEC SQL CREATE TABLE RAS_NULLVALUEPAIRS (
          NullValueOId BIGINT NOT NULL,
          Count INT NOT NULL,
          Low REAL,
          High REAL,
          PRIMARY KEY (NullValueOId, Count)
        );
        if(check("DatabaseIf::create() CREATE TABLE RAS_NULLVALUEPAIRS\0"))
            generateException();

        EXEC SQL CREATE UNIQUE INDEX RAS_NULLVALUEPAIRS_IX
        ON RAS_NULLVALUEPAIRS (NullValueOId, Count);
        if(check("DatabaseIf::create() CREATE UNIQUE INDEX RAS_NULLVALUEPAIRS_IX\0"))
            generateException();
        
        // database updates
		EXEC SQL CREATE TABLE RAS_DBUPDATES (
		    UpdateType VARCHAR(5) NOT NULL,
		    UpdateNumber INTEGER,
		    primary key (UpdateType)
		);
		if(check("DatabaseIf::create() CREATE TABLE RAS_DBUPDATES\0"))
			generateException();

    EXEC SQL INSERT INTO RAS_DBUPDATES values ('rc', 7);
		if(check("DatabaseIf::create() INSERT INTO RAS_DBUPDATES\0"))
			generateException();

        LDEBUG << "EXEC SQL COMMIT WORK";
        EXEC SQL COMMIT WORK;
        if(check("DatabaseIf::create() COMMIT WORK"))
            generateException();

        disconnect();
    }
    catch (r_Error& err)
    {
        // abort TA, ignore any error there
        LDEBUG << "EXEC SQL ABORT WORK;";
        EXEC SQL ABORT WORK;

        LTRACE << "create(" << dbName << ", " << schemaName << ", " << volumeName << ") error caught " << err.what() << " " << err.get_errorno();
        throw; // rethrow exception
    }
}

void
DatabaseIf::destroyDB(const char* dbName)
{
    if (AdminIf::getCurrentDatabaseIf() != 0)
    {
        LTRACE << "another database is already open";
        LFATAL << "Another database is already open.\n" << "Cannot destroy database " << dbName << ".";
        throw r_Error(r_Error::r_Error_DatabaseOpen);
    }
    connect();

    /* this check is omitted, see databaseExists() comment
        // terminate processing of database was not found -- PB 2003-sep-05
        // try
        // {
            if (!databaseExists(dbName))
            {
                LTRACE << "unknown database";
                LFATAL << "Database " << dbName << " not found.\n" << "Cannot destroy database " << dbName << ".";
                throw r_Error(r_Error::r_Error_DatabaseUnknown);
            }
        // }
        // catch (r_Error& err)
        // {
        //  LERROR << "Caught exception while trying to check for existence of database: " << err.what() << " " << err.get_errorno() << " " << err.get_kind();
        //  LERROR << "Continuing with destruction of the database";
        //  LDEBUG << "Continuing destruction of the database after error " << err.get_errorno() << " " << err.get_kind();
        // }
    */

    EXEC SQL BEGIN WORK;
    check("DatabaseIf::destroyDB() BEGIN WORK\0");

    EXEC SQL DROP VIEW IF EXISTS RAS_MDDTYPES_VIEW;
    check("DatabaseIf::destroyDB() DROP VIEW RAS_MDDTYPES_VIEW\0");

    // relblobif
    EXEC SQL DROP TABLE IF EXISTS RAS_TILES;
    check("DatabaseIf::destroyDB() DROP TABLE RAS_TILES\0");

    EXEC SQL DROP TABLE IF EXISTS RAS_ITILES;
    check("DatabaseIf::destroyDB() DROP TABLE RAS_ITILES\0");

    // relcatalogif
    EXEC SQL DROP TABLE IF EXISTS RAS_MDDTYPES;
    check("DatabaseIf::destroyDB() DROP TABLE RAS_MDDTYPES\0");

    EXEC SQL DROP TABLE IF EXISTS RAS_ITMAP;
    check("DatabaseIf::destroyDB() DROP TABLE RAS_ITMAP\0");

    EXEC SQL DROP TABLE IF EXISTS RAS_MDDBASETYPES;
    check("DatabaseIf::destroyDB() DROP TABLE RAS_MDDBASETYPES\0");

    EXEC SQL DROP TABLE IF EXISTS RAS_MDDDIMTYPES;
    check("DatabaseIf::destroyDB() DROP TABLE RAS_MDDDIMENSIONTYPES\0");

    EXEC SQL DROP TABLE IF EXISTS RAS_MDDDOMTYPES;
    check("DatabaseIf::destroyDB() DROP TABLE RAS_MDDDOMAINTYPES\0");

    EXEC SQL DROP TABLE IF EXISTS RAS_SETTYPES;
    check("DatabaseIf::destroyDB() DROP TABLE RAS_SETTYPES\0");

    EXEC SQL DROP TABLE IF EXISTS RAS_BASETYPENAMES;
    check("DatabaseIf::destroyDB() DROP TABLE RAS_BASETYPENAMES\0");

    EXEC SQL DROP INDEX IF EXISTS RAS_BASETYPES_IX;
    check("DatabaseIf::destroyDB() DROP INDEX RAS_BASETYPES_IX\0");

    EXEC SQL DROP TABLE IF EXISTS RAS_BASETYPES;
    check("DatabaseIf::destroyDB() DROP TABLE RAS_BASETYPES\0");

    EXEC SQL DROP TABLE IF EXISTS RAS_DOMAINS;
    check("DatabaseIf::destroyDB() DROP TABLE RAS_DOMAINS\0");

    EXEC SQL DROP TABLE IF EXISTS RAS_DOMAINVALUES;
    check("DatabaseIf::destroyDB() DROP TABLE RAS_DOMAINVALUES\0");

    // relmddif
    // referes to DBMDDCollOIdEntry
    EXEC SQL DROP TABLE IF EXISTS RAS_MDDCOLLECTIONS;
    check("DatabaseIf::destroyDB() DROP TABLE RAS_MDDCOLLECTIONS\0");

    // referes to MDDSet
    EXEC SQL DROP TABLE IF EXISTS RAS_MDDCOLLNAMES;
    check("DatabaseIf::destroyDB() DROP TABLE RAS_MDDCOLLNAMES\0");

    EXEC SQL DROP TABLE IF EXISTS RAS_MDDOBJECTS;
    check("DatabaseIf::destroyDB() DROP TABLE RAS_MDDOBJECTS\0");

    // relindexif
    // may not be needed
    EXEC SQL DROP TABLE IF EXISTS RAS_HIERIX;
    check("DatabaseIf::destroyDB() DROP TABLE RAS_HIERIX\0");

    EXEC SQL DROP INDEX IF EXISTS RAS_HIERIXDYN_IX;
    check("DatabaseIf::destroyDB() DROP INDEX RAS_HIERIXDYN_IX\0");

    EXEC SQL DROP TABLE IF EXISTS RAS_HIERIXDYN;
    check("DatabaseIf::destroyDB() DROP TABLE RAS_HIERIXDYN\0");

    EXEC SQL DROP TABLE IF EXISTS RAS_STORAGE;
    check("DatabaseIf::destroyDB() DROP TABLE RAS_STORAGE\0");

    EXEC SQL DROP TABLE IF EXISTS RAS_COUNTERS;
    check("DatabaseIf::destroyDB() DROP TABLE RAS_COUNTERS\0");

    EXEC SQL DROP TABLE IF EXISTS RAS_PYRAMIDS;
    check("DatabaseIf::destroyDB() DROP TABLE RAS_PYRAMIDS\0");

    /* DROP INDEX, TABLE for LockManager: START */

    EXEC SQL DROP INDEX IF EXISTS RAS_LOCKMANAGER_IX;
	check("DatabaseIf::destroyDB() DROP INDEX RAS_LOCKMANAGER_IX\0");

    EXEC SQL DROP TABLE IF EXISTS RAS_LOCKEDTILES;
	check("DatabaseIf::destroyDB() DROP TABLE RAS_LOCKEDTILES\0");

	/* DROP INDEX, TABLE for LockManager: END */

    EXEC SQL DROP INDEX IF EXISTS RAS_RCINDEXDYN_IX;
    check("DatabaseIf::destroyDB() DROP INDEX RAS_RCINDEXDYN_IX\0");

    EXEC SQL DROP TABLE IF EXISTS RAS_RCINDEXDYN;
    check("DatabaseIf::destroyDB() DROP TABLE RAS_RCINDEXDYN\0");

    EXEC SQL DROP TABLE IF EXISTS RAS_ADMIN;
    check("DatabaseIf::destroyDB() DROP TABLE RAS_ADMIN\0");

    EXEC SQL COMMIT WORK;
    check("DatabaseIf::destroyDB() COMMIT\0");

    disconnect();
}

#ifndef RMANVERSION
#define RMANVERSION "v9.7.0-unknown"
#endif
#define LONGVER 9700
long
DatabaseIf::rmanverToLong()
{
        string s(RMANVERSION);
        // return default version if RMANVERSION length is 0
        if(s.empty())
                return LONGVER;
        string versionstr;
        string final;
        int i;
        int c;
        long longver = 0;
        size_t first = s.find_first_of("0123456789");
        // return default version if no number found in s
        if (first == string::npos)
                return LONGVER;
        size_t last = s.find_first_of("-");
        versionstr = s.substr(first, last - first);

        // split the versionstr using . as delimiter
        string delim = ".";
        size_t start = 0;
        size_t end = versionstr.find(delim);
        int mulfactor = 1000;
        double verpart;
        while (end != string::npos)
        {
                // convert the split part to double
                verpart = atol(versionstr.substr(start, end - start).c_str());
                longver += verpart * mulfactor;
                mulfactor /= 10;
                start = end + delim.length();
                end = versionstr.find(delim, start);
        }
        verpart =  atol(versionstr.substr(start, versionstr.length()).c_str());
        longver += verpart * mulfactor;
        return longver;
}

