#include "config.h"
#include "mymalloc/mymalloc.h"

/*
* This file is part of rasdaman community.
*
* Rasdaman community is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* Rasdaman community is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with rasdaman community.  If not, see <http://www.gnu.org/licenses/>.
*
* Copyright 2003, 2004, 2005, 2006, 2007, 2008, 2009 Peter Baumann /
rasdaman GmbH.
*
* For more information please see <http://www.rasdaman.org>
* or contact Peter Baumann via <baumann@rasdaman.com>.
*/
/*************************************************************
 *
 *
 * PURPOSE:
 *   Code with embedded SQL for PostgreSQL DBMS
 *
 *
 * COMMENTS:
 *
 ************************************************************/

// PG stuff:
#include "libpq-fe.h"           /* C interface to PgSQL */
#include "libpq/libpq-fs.h"     /* large object (lo) api */

#include "debug-srv.hh"

#include "dbrcindexds.hh"
#include "reladminif/sqlerror.hh"
#include <logging.hh>

// general embedded SQL related definitions
EXEC SQL include "../reladminif/sqlglobals.h";

// container size for index node
// BEWARE: keep these parameters always consistent!
#define BYTES_PER_TUPLE 3990
EXEC SQL define SQL_BYTES_PER_TUPLE 3991;

// libpg connection maintenance
extern PGconn *pgConn;

r_Bytes
DBRCIndexDS::BytesPerTuple = BYTES_PER_TUPLE;

void
DBRCIndexDS::insertInDb()
{
    int header = 1010; 
    int headersize = 4;
	
#ifdef NOTYET   // should be in future
    /*
        EXEC SQL BEGIN DECLARE SECTION;
    */
#endif //NOTYET
    long long id2;
    int       count2;
    Oid       blobOid;
    char      pgQuery[SQL_QUERY_BUFFER_SIZE];     // prelim
    PGresult  *pgResult = NULL;          // prelim
#ifdef NOTYET   // should be in future
    /*
        EXEC SQL END DECLARE SECTION;
    */
#endif //NOTYET

    // alternative solution for now:

    // (1) --- prepare buffer
    id2 = myOId;
    r_Dimension dimension = myDomain.dimension();

    //number of bytes for bounds in 1 minterval
    r_Bytes boundssize = sizeof(r_Range) * dimension;
    //number of bytes for fixes in 1 minterval
    r_Bytes fixessize = sizeof(char) * dimension;
    //number of bytes for the dynamic data
    r_Bytes completesize = sizeof(header) + sizeof(r_Dimension) + sizeof(long long) 
                           + sizeof(OId::OIdCounter) + sizeof(OId::OIdCounter) 
                           + boundssize * 2 + fixessize * 2;

    char* completebuffer = static_cast<char*>(mymalloc(completesize));
    // At a later stage get rid of all the unnecessary mallocs and memcpys, 
    // but first make sure that everything works as expected

    r_Range* upperboundsbuf = static_cast<r_Range*>(mymalloc(boundssize));
    r_Range* lowerboundsbuf = static_cast<r_Range*>(mymalloc(boundssize));
    char* upperfixedbuf = static_cast<char*>(mymalloc(fixessize));
    char* lowerfixedbuf = static_cast<char*>(mymalloc(fixessize));

    LTRACE << "complete " << completesize << " bounds " << boundssize << " fixes " << fixessize;
    LDEBUG << "DBRCIndexDS: complete " << completesize << " bounds " << boundssize << " fixes " << fixessize;

    // insert myDomain in buffers
    myDomain.insertInDb(&(lowerboundsbuf[0]), &(upperboundsbuf[0]), &(lowerfixedbuf[0]), &(upperfixedbuf[0]));
    LTRACE << "domain " << myDomain << " stored as " << InlineMinterval(dimension, &(lowerboundsbuf[0]), &(upperboundsbuf[0]), &(lowerfixedbuf[0]), &(upperfixedbuf[0]));
    LDEBUG << "DBRCIndexDS: domain " << myDomain << " stored as " << InlineMinterval(dimension, &(lowerboundsbuf[0]), &(upperboundsbuf[0]), &(lowerfixedbuf[0]), &(upperfixedbuf[0]));

    char* insertionpointer = completebuffer;

    // write the buffers in the complete buffer
    // this indirection is necessary because of memory alignment of longs...
    // insert dimension
	
    memcpy(insertionpointer, &header, sizeof(header));
    insertionpointer = insertionpointer + sizeof(header);
	
    memcpy(insertionpointer, &dimension, sizeof(r_Dimension));
    insertionpointer = insertionpointer + sizeof(r_Dimension);

    // insert oid type
    long long tmpMyBaseOIdType;
    tmpMyBaseOIdType = myBaseOIdType;
    memcpy(insertionpointer, &tmpMyBaseOIdType, sizeof(long long));
    insertionpointer = insertionpointer + sizeof(long long);

    // insert oid counter
    memcpy(insertionpointer, &myBaseCounter, sizeof(OId::OIdCounter));
    insertionpointer = insertionpointer + sizeof(OId::OIdCounter);

    // insert oid counter
    memcpy(insertionpointer, &mySize, sizeof(OId::OIdCounter));    
    insertionpointer = insertionpointer + sizeof(OId::OIdCounter);

    // insert domains
    memcpy(insertionpointer, lowerboundsbuf, boundssize);
    insertionpointer = insertionpointer + boundssize;
    free(lowerboundsbuf);

    memcpy(insertionpointer, upperboundsbuf, boundssize);
    insertionpointer = insertionpointer + boundssize;
    free(upperboundsbuf);

    memcpy(insertionpointer, lowerfixedbuf, fixessize);
    insertionpointer = insertionpointer + fixessize;
    free(lowerfixedbuf);

    memcpy(insertionpointer, upperfixedbuf, fixessize);
    free(upperfixedbuf);

#ifdef RMANDEBUG        // dump low-level blob byte string
    {
        char printbuf[10000];
        (void) sprintf( printbuf, "DBRCIndexDS::insertInDb(): [%d]", completesize );
#if 0   // extra verbose output: dump buffer
        char bytebuf[3];
        for (long i = 0; i < completesize; i++)
        {
            (void) sprintf( bytebuf, " %2X", (unsigned char) completebuffer[i] );
            strcat( printbuf, bytebuf );
        }
#endif // 0
        LDEBUG << printbuf;
    }
#endif //RMANDEBUG

    // (2) --- create, open, write, close blob; generates new 'oid' for subsequent storage in tuple
    LDEBUG << "lo_creat()";
    blobOid = lo_creat( pgConn, INV_READ|INV_WRITE );      // create -- not clear what INV_* here means so indicate all
    if (blobOid == 0)
    {
        free(completebuffer);
        completebuffer = NULL;
        LFATAL << "DBRCIndexDS::insertInDb() cannot create blob, error: " << PQerrorMessage(pgConn);
        generateException();
    }
    LDEBUG << "lo_open() for oid " << blobOid;
    int fd = lo_open( pgConn, blobOid, INV_WRITE );  // no error code indicated, 0 seems to be no error
    LDEBUG << "lo_write() for fd " << fd << " with " << completesize << " bytes";
    int loResult = lo_write( pgConn, fd, completebuffer, completesize );
    if (loResult < 0)
    {
        free(completebuffer);
        completebuffer = NULL;
        LFATAL << "DBRCIndexDS::insertInDb() cannot write blob, error: " << PQerrorMessage(pgConn);
        generateException();
    }
    else if (loResult != static_cast<int>(completesize))      // did not get all
    {
        free(completebuffer);
        completebuffer = NULL;
        LTRACE << "BLOB (" << myOId << ") insert: wrote " << loResult << " instead of " << completesize << " bytes";
        generateException();
    }
    LDEBUG << "lo_close(), " << completesize << " bytes written";
    loResult = lo_close( pgConn, fd );
    if (loResult < 0)               // can't close, don't know if data are written
    {
        free(completebuffer);
        completebuffer = NULL;
        LFATAL << "DBRCIndexDS::insertInDb() ignoring lo_close() error: " << PQerrorMessage(pgConn);
        generateException();
    }
    free(completebuffer);

    // (3) --- insert HIERIX tuple into db
    count2 = 0; // we only have one entry
#ifdef NOTYET   // should be in future
    /*
        LDEBUG << "EXEC SQL INSERT INTO RAS_RCINDEXDYN ( Id, Count, DynData ) VALUES ( " << id2 << "," << count2 << "," << blobOid << " )";
        EXEC SQL INSERT INTO RAS_RCINDEXDYN ( Id, Count, DynData )
            VALUES ( :id2, :count2, :blobOid );
        if (SQLCODE != SQLOK)
        {
            check("DBRCIndexDS::insertInDb() insert into RAS_HIERIXDYN\0");
            generateException();
        }
    */
#endif // NOTYET
    // alternative solution for now:
    (void) snprintf( pgQuery, sizeof(pgQuery), "INSERT INTO RAS_RCINDEXDYN ( Id, Count, DynData ) VALUES ( %lld, %d, %d )", id2, count2, blobOid );
    LDEBUG << pgQuery;
    pgResult = PQexec( pgConn, pgQuery );
    if (PQresultStatus(pgResult) != PGRES_COMMAND_OK)
    {
        PQclear( pgResult );
        generateException();
    }
    PQclear( pgResult );

    // (4) --- dbobject insert
    DBObject::insertInDb();
}

void
DBRCIndexDS::readFromDb()
{
#ifdef RMANBENCHMARK
    DBObject::readTimer.resume();
#endif

#ifdef NOTYET   // should be in future
    /*
        EXEC SQL BEGIN DECLARE SECTION;
    */
#endif //NOTYET

    int blobformat;
    int headersize = 0;
    int header = 0;
	
    long long id1;
    Oid       blobOid;
    char      pgQuery[SQL_QUERY_BUFFER_SIZE];        // prelim
    PGresult *pgResult = NULL;  // prelim
#ifdef NOTYET   // should be in future
    /*
        EXEC SQL END DECLARE SECTION;
    */
#endif //NOTYET

    // (1) --- prepare variables
    id1 = myOId;

    // (2) --- get tuple
#ifdef NOTYET   // should be in future
    /*
        LDEBUG << "EXEC SQL SELECT DynData FROM RAS_RCINDEXDYN WHERE Id = " << id1;
        EXEC SQL SELECT DynData FROM RAS_RCINDEXDYN WHERE Id = :id1;
        if (SQLCODE != SQLOK)
        {
            check("DBRCIndexDS::readFromDb() select from RAS_RCINDEXDYN");
            generateException();
        }
    */
#endif // NOTYET
    // alternative solution for now:
    (void) snprintf( pgQuery, sizeof(pgQuery), "SELECT DynData FROM RAS_RCINDEXDYN WHERE Id = %lld", id1 );
    LDEBUG << pgQuery;
    pgResult = PQexec( pgConn, pgQuery );
    if (PQresultStatus(pgResult) != PGRES_TUPLES_OK)
    {
        PQclear( pgResult );
        generateException();
    }
    blobOid = static_cast<Oid>(atoi( PQgetvalue( pgResult, 0, 0 ) ));     // extract value from result
    PQclear( pgResult );

    // (3) --- open, read, close blob
    LDEBUG << "lo_open()";
    int fd = lo_open( pgConn, blobOid, INV_READ );      // open; manual tells no error indication
    LDEBUG << "lo_lseek() end";
    int blobSize = lo_lseek( pgConn, fd, 0, SEEK_END ); // determine blob size; FIXME: more efficient method??
    LDEBUG << "lo_lseek() start";
    (void) lo_lseek( pgConn, fd, 0, SEEK_SET );     // rewind for reading
    char* completebuffer = static_cast<char*>(mymalloc(static_cast<size_t>(blobSize)));   // receives blob contents
    if (completebuffer == NULL)
    {
        LFATAL << "DBRCIndexDS::readFromDb() cannot allocate blob buffer";
        throw r_Error( r_Error::r_Error_MemoryAllocation );
    }
    LDEBUG << "lo_read() for " << blobSize << " bytes";   // read blob
    int loResult = lo_read( pgConn, fd, completebuffer, static_cast<size_t>(blobSize) );
    if (loResult < 0)
    {
        LFATAL << "DBRCIndexDS::readFromDb() cannot read blob, error: " << loResult;
        throw r_Error( r_Error::r_Error_BaseDBMSFailed );
    }
    else if (loResult != blobSize)              // did not get all
    {
        LTRACE << "BLOB (" << myOId << ") read: want to read (" << blobSize << " bytes, but got " << loResult << " bytes";
        throw r_Error( r_Error::r_Error_LimitsMismatch );
    }
    LDEBUG << "lo_close()";
    int ignoredPgResult = lo_close( pgConn, fd );       // close blob
    if (ignoredPgResult < 0)                // we note, but ignore errors, as we have the data
    {
        LERROR << "DBRCIndexDS::readFromDb() ignoring lo_close() error: " << ignoredPgResult;
        LDEBUG << "DBRCIndexDS::readFromDb: ignoring lo_close() error: " << ignoredPgResult;
    }

#ifdef RMANDEBUG        // dump low-level blob byte string
    {
        char printbuf[10000];
        (void) sprintf( printbuf, "DBRCIndexDS::readFromDb(): [%d]", blobSize );
        char bytebuf[3];
        for (long i = 0; i < blobSize; i++)
        {
            (void) sprintf( bytebuf, " %2X", (unsigned char) completebuffer[i] );
            strcat( printbuf, bytebuf );
        }
        LDEBUG << printbuf;
    }
#endif // RMANDEBUG

    // (4) --- fill variables and buffers
    unsigned int bytesdone;
    r_Dimension dimension = 0;

	r_Bytes boundssize;
	r_Bytes newboundssize = 0;

    (void) memcpy(&header, &completebuffer[0], sizeof(int));
    // if header >=1009 then this is considered to be a real header, 
    // otherwise the value needs to be interpreted as a dimension

    // blobformat == 8: old format
    // blobformat == 9: OIDcounter is now long, but r_Range is still int
    // blobformat == 10: r_Range is long as well
    
	// old format
    if (header <= 1008) {
        blobformat = 8;
        // no header, first 4 bytes are actually the dimension;
        headersize = 0;
        dimension = static_cast<r_Dimension>(header);
        bytesdone = static_cast<r_Dimension>(headersize) + sizeof(r_Dimension);

        // this is needed for correct assignment
        short tmpBaseOIdType;
        memcpy(&tmpBaseOIdType, &(completebuffer[bytesdone]), sizeof(short));
        myBaseOIdType = static_cast<OId::OIdType>(tmpBaseOIdType);
        bytesdone += sizeof(short);

        int tmpBaseCounter;
        memcpy(&tmpBaseCounter, &(completebuffer[bytesdone]), sizeof(int));
        myBaseCounter = tmpBaseCounter;
        bytesdone += sizeof(int);
		
        unsigned int tmpMySize;
        memcpy(&tmpMySize, &(completebuffer[bytesdone]), sizeof(unsigned int));
        mySize = tmpMySize;
        bytesdone += sizeof(unsigned int);
	} else {
        blobformat = header - 1000;
        // first 4 bytes are the header;
        headersize = 4;
        memcpy(&dimension, &completebuffer[headersize], sizeof(r_Dimension));
        bytesdone = static_cast<unsigned int>(headersize) + sizeof(r_Dimension);
    }

    if (blobformat == 8 || blobformat == 9) {
        // r_Range is still an int
        boundssize = sizeof(int) * dimension;   //number of bytes for bounds in 2 domains
        newboundssize = sizeof(r_Range) * dimension;   //number of bytes for bounds in 2 domains
    } else {
        boundssize = sizeof(r_Range) * dimension;   //number of bytes for bounds in 2 domains
    }

    LDEBUG << "blobformat: " << blobformat << " boundssize: " << boundssize << " dimension: " << dimension;
    
    if (blobformat >= 9) {

        // this is needed for correct assignment
        long long tmpBaseOIdType;
        memcpy(&tmpBaseOIdType, &(completebuffer[bytesdone]), sizeof(long long));
        myBaseOIdType = static_cast<OId::OIdType>(tmpBaseOIdType);
        bytesdone += sizeof(long long);

        long long tmpBaseCounter;
        memcpy(&myBaseCounter, &(completebuffer[bytesdone]), sizeof(OId::OIdCounter));
        bytesdone += sizeof(OId::OIdCounter);
		
        memcpy(&mySize, &(completebuffer[bytesdone]), sizeof(OId::OIdCounter));
        bytesdone += sizeof(OId::OIdCounter);
    }

    r_Bytes fixessize = sizeof(char) * dimension;       //number of bytes for fixes in 2 domains
    r_Bytes completesize = boundssize * 2 + fixessize * 2;  //number of bytes for the dynamic data
    char *dynamicBuffer = &completebuffer[bytesdone];   // ptr to start of dynamic part of buffer

    // additional plausi check
    if (blobSize != static_cast<int>(bytesdone + completesize))
    {
        LFATAL << "DBRCIndexDS::readFromDb() blob size inconsistency: blobSize (" << blobSize << " != bytesdone (" << bytesdone << ") + completesize (" << completesize << ")";
        LDEBUG << "DBRCIndexDS::readFromDb() blob size inconsistency: blobSize (" << blobSize << " != bytesdone (" << bytesdone << ") + completesize (" << completesize << ")";
        throw r_Error( r_Error::r_Error_LimitsMismatch );
    }

    LTRACE << "dimension " << dimension << ", base oid type " << myBaseOIdType << ", base counter " << myBaseCounter << ", size " << mySize << ", complete data size " << completesize;

    int* oldupperboundsbuf = NULL;
    int* oldlowerboundsbuf = NULL;

    r_Range* upperboundsbuf;
    r_Range* lowerboundsbuf;

    if (blobformat == 8 || blobformat == 9) {
        oldupperboundsbuf = static_cast<int*>(mymalloc(boundssize));
        oldlowerboundsbuf = static_cast<int*>(mymalloc(boundssize));
        memcpy(oldlowerboundsbuf, dynamicBuffer, boundssize);
        memcpy(oldupperboundsbuf, &dynamicBuffer[boundssize], boundssize);
        upperboundsbuf = static_cast<r_Range*>(mymalloc(newboundssize));
        lowerboundsbuf = static_cast<r_Range*>(mymalloc(newboundssize));
        // we need to copy all values to new variables 
        for (long i = 0; i < dimension; i++) {
            upperboundsbuf[i] = static_cast<r_Range>(oldupperboundsbuf[i]);
            lowerboundsbuf[i] = static_cast<r_Range>(oldlowerboundsbuf[i]);
        }
    } else {
        upperboundsbuf = static_cast<r_Range*>(mymalloc(boundssize));
        lowerboundsbuf = static_cast<r_Range*>(mymalloc(boundssize));
        memcpy(lowerboundsbuf, dynamicBuffer, boundssize);
        memcpy(upperboundsbuf, &dynamicBuffer[boundssize], boundssize);
    }

    char* upperfixedbuf = static_cast<char*>(mymalloc(fixessize));
    char* lowerfixedbuf = static_cast<char*>(mymalloc(fixessize));

    // HST at later stage remove unnecessary copying
    // all dynamic data is in dynamicBuffer
    // put that stuff in the correct buffers
    memcpy(lowerfixedbuf, &dynamicBuffer[boundssize * 2], fixessize);
    memcpy(upperfixedbuf, &dynamicBuffer[boundssize * 2 + fixessize], fixessize);

    // all dynamic data is in its buffer
    free (completebuffer);
    dynamicBuffer = completebuffer = NULL;

    // rebuild attributes from buffers
    myDomain = InlineMinterval(dimension, &(lowerboundsbuf[0]), &(upperboundsbuf[0]), &(lowerfixedbuf[0]), &(upperfixedbuf[0]));
    LTRACE << "domain " << myDomain << " constructed from " << InlineMinterval(dimension, &(lowerboundsbuf[0]), &(upperboundsbuf[0]), &(lowerfixedbuf[0]), &(upperfixedbuf[0]));

	if (blobformat == 8 || blobformat == 9) {
		free(oldlowerboundsbuf);
		free(oldupperboundsbuf);
	}
    free(upperboundsbuf);
    upperboundsbuf = NULL;
    free(lowerboundsbuf);
    lowerboundsbuf = NULL;
    free(upperfixedbuf);
    upperfixedbuf = NULL;
    free(lowerfixedbuf);
    lowerfixedbuf = NULL;

#ifdef RMANBENCHMARK
    DBObject::readTimer.pause();
#endif

    // (5) --- dbobject read
    DBObject::readFromDb();

}

void
DBRCIndexDS::deleteFromDb()
{
#ifdef NOTYET   // should be in future
    /*
        EXEC SQL BEGIN DECLARE SECTION;
    */
#endif // NOTYET
    long long id3;
    Oid       blobOid;
    char      pgQuery[SQL_QUERY_BUFFER_SIZE];        // prelim
    PGresult *pgResult = NULL;  // prelim
#ifdef NOTYET   // should be in future
    /*
        EXEC SQL END DECLARE SECTION;
    */
#endif // NOTYET

    // (1) --- set variables
    id3 = myOId;

    // (2) --- fetch blob oid
#ifdef NOTYET   // should be in future
    /*
        LDEBUG << "EXEC SQL SELECT DynData FROM RAS_RCINDEXDYN WHERE Id = " << id3;
        EXEC SQL SELECT DynData FROM RAS_RCINDEXDYN
            WHERE Id = :id3;
        if (check("DBRCIndexDS::deleteFromDb() RAS_RCINDEX") != 0)
            generateException();
    */
#endif // NOTYET
    // alternative solution for now:
    (void) snprintf( pgQuery, sizeof(pgQuery), "SELECT DynData FROM RAS_RCINDEXDYN WHERE Id = %lld", id3 );
    LDEBUG << pgQuery;
    pgResult = PQexec( pgConn, pgQuery );
    if (PQresultStatus(pgResult) != PGRES_TUPLES_OK)
    {
        PQclear( pgResult );
        generateException();
    }
    blobOid = static_cast<Oid>(atoi( PQgetvalue( pgResult, 0, 0 ) ));     // extract value from result
    PQclear( pgResult );

    // (3) --- delete blob
    int loResult = lo_unlink( pgConn, blobOid );
    if (loResult < 0)                   // no disaster if we can't so no exception
    {
        LDEBUG << "DBRCIndexDS::deleteFromDb() warning: libpq 'unlink blob' error: " << PQerrorMessage(pgConn);
    }

    // (3) --- delete tuple
#ifdef NOTYET   // should be in future
    /*
        LDEBUG << "EXEC SQL DELETE FROM RAS_RCINDEXDYN WHERE Id = " << id3;
        EXEC SQL DELETE FROM RAS_RCINDEXDYN
            WHERE Id = :id3;
        if (SQLCODE != SQLOK)
        {
            check("DBRCIndexDS::deleteFromDb() delete from RAS_RCINDEX");
            generateException();
        }
    */
#endif // NOTYET
    // alternative solution for now:
    (void) snprintf( pgQuery, sizeof(pgQuery), "DELETE FROM RAS_RCINDEXDYN WHERE Id = %lld", id3 );
    LDEBUG << pgQuery;
    pgResult = PQexec( pgConn, pgQuery );
    if (PQresultStatus(pgResult) != PGRES_COMMAND_OK)
    {
        PQclear( pgResult );
        generateException();
    }

    // (4) --- dbobject delete
    DBObject::deleteFromDb();
}

